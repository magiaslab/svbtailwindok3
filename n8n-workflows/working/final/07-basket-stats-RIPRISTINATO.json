{
  "name": "07 - Basket Stats RIPRISTINATO",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "value": "0 8 * * 1,4"
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "Schedule",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [260, 300]
    },
    {
      "parameters": {
        "url": "https://www.playbasket.it/toscana/league.php?lt=2&lf=M&lr=TO&lp=FI&lc=C%2FM&lg=1&mod=st",
        "responseFormat": "string",
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3
          }
        }
      },
      "id": "http-request",
      "name": "Get HTML",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [480, 300]
    },
    {
      "parameters": {
        "jsCode": "// === BASKET STATS SCRAPER - VERSIONE FINALE ===\nconsole.log('üöÄ Inizio scraping basket stats FINAL...');\n\n// Accesso ai dati HTML\nlet htmlData = '';\nif (items && items.length > 0) {\n  const item = items[0];\n  console.log('üì• Item ricevuto:', typeof item, Object.keys(item || {}));\n  \n  if (item.json && item.json.data && typeof item.json.data === 'string' && item.json.data.length > 1000) {\n    htmlData = item.json.data;\n    console.log('‚úÖ HTML trovato in item.json.data');\n  } else if (item.json && typeof item.json === 'string' && item.json.length > 1000) {\n    htmlData = item.json;\n    console.log('‚úÖ HTML trovato in item.json (string)');\n  } else if (item.data && typeof item.data === 'string' && item.data.length > 1000) {\n    htmlData = item.data;\n    console.log('‚úÖ HTML trovato in item.data');\n  }\n}\n\nif (!htmlData || htmlData.length < 1000) {\n  return [{\n    json: {\n      error: 'HTML_NOT_FOUND',\n      message: 'Impossibile accedere ai dati HTML'\n    }\n  }];\n}\n\n// Parsing della tabella\nconst tableRegex = /<table[^>]*class=[\"']league_standings_ranking stats[\"'][^>]*>([\\s\\S]*?)<\\/table>/i;\nconst tableMatch = htmlData.match(tableRegex);\n\nif (!tableMatch) {\n  return [{\n    json: {\n      error: 'TABLE_NOT_FOUND',\n      message: 'Tabella non trovata'\n    }\n  }];\n}\n\n// Estrazione righe\nconst rowRegex = /<tr[^>]*>([\\s\\S]*?)<\\/tr>/gi;\nconst rows = [];\nlet match;\n\nwhile ((match = rowRegex.exec(tableMatch[1])) !== null) {\n  rows.push(match[1]);\n}\n\nconst standings = [];\n\n// Parsing squadre (salta header)\nfor (let i = 1; i < rows.length; i++) {\n  const rowContent = rows[i];\n  const cellRegex = /<td[^>]*>([\\s\\S]*?)<\\/td>/gi;\n  const cells = [];\n  let cellMatch;\n  \n  while ((cellMatch = cellRegex.exec(rowContent)) !== null) {\n    cells.push(cellMatch[1]);\n  }\n  \n  if (cells.length >= 11) {\n    const cleanText = (html) => html.replace(/<[^>]*>/g, '').replace(/\\s+/g, ' ').trim();\n    const extractHref = (html) => {\n      const match = html.match(/href=[\"']([^\"']*)[\"']/);\n      return match ? match[1] : '';\n    };\n    \n    const position = parseInt(cleanText(cells[0])) || standings.length + 1;\n    const teamCell = cells[1] || '';\n    const teamName = cleanText(teamCell);\n    const teamLink = extractHref(teamCell);\n    const teamIdMatch = teamLink.match(/obj=(\\d+)/);\n    const teamId = teamIdMatch ? teamIdMatch[1] : '';\n    const points = parseInt(cleanText(cells[2])) || 0;\n    const games = parseInt(cleanText(cells[4])) || 0;\n    const wins = parseInt(cleanText(cells[5])) || 0;\n    const losses = parseInt(cleanText(cells[6])) || 0;\n    const percentage = parseFloat(cleanText(cells[7])) || 0;\n    const streak = cleanText(cells[8]) || '-';\n    const pointsFor = parseInt(cleanText(cells[10])) || 0;\n    const quality = parseFloat(cleanText(cells[9])) || 50;\n    const pointsAgainst = games > 0 ? Math.max(0, Math.round(pointsFor - ((quality - 50) * games / 10))) : 0;\n    \n    standings.push({\n      position: position,\n      team: teamName,\n      teamId: teamId,\n      teamLink: teamLink.startsWith('http') ? teamLink : `https://www.playbasket.it/toscana/${teamLink}`,\n      points: points,\n      pointsPerGame: games > 0 ? (points / games).toFixed(2) : '0.00',\n      games: games,\n      wins: wins,\n      losses: losses,\n      percentage: percentage,\n      streak: streak,\n      pointsFor: pointsFor,\n      pointsAgainst: pointsAgainst,\n      quality: quality.toFixed(2),\n      pointsForPerGame: games > 0 ? Math.round(pointsFor / games) : 0,\n      pointsAgainstPerGame: games > 0 ? Math.round(pointsAgainst / games) : 0\n    });\n  }\n}\n\nif (standings.length === 0) {\n  return [{\n    json: {\n      error: 'NO_TEAMS_FOUND',\n      message: 'Nessuna squadra trovata'\n    }\n  }];\n}\n\nconst now = new Date().toISOString();\nconst statsData = {\n  standings: standings,\n  teamStats: {},\n  lastUpdate: now,\n  season: '2025-2026',\n  competition: 'Serie C Maschile Toscana',\n  conference: 'Conference Nord-Ovest',\n  group: 'Girone B',\n  totalTeams: standings.length,\n  source: 'playbasket.it',\n  status: 'active'\n};\n\nstandings.forEach(team => {\n  statsData.teamStats[team.team] = {\n    position: team.position,\n    points: team.points,\n    games: team.games,\n    wins: team.wins,\n    losses: team.losses,\n    winPercentage: team.percentage,\n    pointsFor: team.pointsFor,\n    pointsAgainst: team.pointsAgainst,\n    pointDifference: team.pointsFor - team.pointsAgainst,\n    averagePointsFor: team.pointsForPerGame,\n    averagePointsAgainst: team.pointsAgainstPerGame\n  };\n});\n\nreturn [{ json: { success: true, data: statsData, totalTeams: standings.length, lastUpdate: now } }];"
      },
      "id": "parse-data",
      "name": "Parse Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [700, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [{ "value1": "={{$json.success}}", "value2": true }],
          "number": [{ "value1": "={{$json.totalTeams}}", "operation": "larger", "value2": 5 }]
        }
      },
      "id": "quality-check",
      "name": "Quality Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [920, 300]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/magiaslab/svbtailwindok3/contents/src/data/stats/serie-c-stats.json",
        "options": {
          "headers": {
            "Accept": "application/vnd.github.v3+json",
            "Authorization": "token YOUR_GITHUB_TOKEN_HERE"
          },
          "qs": { "ref": "master" }
        }
      },
      "id": "get-sha",
      "name": "Get SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1140, 200]
    },
    {
      "parameters": {
        "jsCode": "const parseData = $('Parse Data').first().json;\nconst shaData = $input.first().json;\n\nif (!parseData.success || !parseData.data) {\n  throw new Error('Dati di parsing non validi');\n}\n\nif (!shaData || !shaData.sha) {\n  throw new Error('SHA non trovato');\n}\n\nconst jsonContent = JSON.stringify(parseData.data, null, 2);\nconst base64Content = Buffer.from(jsonContent, 'utf8').toString('base64');\n\nconst now = new Date();\nconst dateStr = now.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric' });\nconst timeStr = now.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });\n\nreturn [{ json: {\n  message: `ü§ñ Aggiornamento automatico statistiche Serie C - ${dateStr} ${timeStr}`,\n  content: base64Content,\n  sha: shaData.sha,\n  branch: 'master'\n}}];"
      },
      "id": "prepare-github",
      "name": "Prepare GitHub Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1360, 200]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/magiaslab/svbtailwindok3/contents/src/data/stats/serie-c-stats.json",
        "requestMethod": "PUT",
        "jsonParameters": true,
        "options": {
          "headers": {
            "Authorization": "token YOUR_GITHUB_TOKEN_HERE",
            "Content-Type": "application/json",
            "Accept": "application/vnd.github.v3+json"
          }
        },
        "bodyParametersJson": "={{ $json }}"
      },
      "id": "update-github",
      "name": "Update GitHub",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1580, 200]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { timestamp: new Date().toISOString(), success: true, message: '‚úÖ Workflow completato con successo' }}];"
      },
      "id": "success",
      "name": "Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1800, 200]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { timestamp: new Date().toISOString(), success: false, message: '‚ùå Workflow fallito' }}];"
      },
      "id": "failure",
      "name": "Failure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1140, 400]
    }
  ],
  "connections": {
    "Schedule": { "main": [[{ "node": "Get HTML", "type": "main", "index": 0 }]] },
    "Get HTML": { "main": [[{ "node": "Parse Data", "type": "main", "index": 0 }]] },
    "Parse Data": { "main": [[{ "node": "Quality Check", "type": "main", "index": 0 }]] },
    "Quality Check": { "main": [[{ "node": "Get SHA", "type": "main", "index": 0 }], [{ "node": "Failure", "type": "main", "index": 0 }]] },
    "Get SHA": { "main": [[{ "node": "Prepare GitHub Data", "type": "main", "index": 0 }]] },
    "Prepare GitHub Data": { "main": [[{ "node": "Update GitHub", "type": "main", "index": 0 }]] },
    "Update GitHub": { "main": [[{ "node": "Success", "type": "main", "index": 0 }]] }
  },
  "pinData": {},
  "settings": { "executionOrder": "v1" },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-10-06T10:22:00.000Z",
  "versionId": "1"
}
