{
  "name": "üèÄ Test Update GitHub File",
  "nodes": [
    {
      "parameters": {
        "url": "https://www.playbasket.it/toscana/league.php?lt=2&lf=M&lr=TO&lp=FI&lc=C%2FM&lg=1&mod=st",
        "responseFormat": "string"
      },
      "id": "node1",
      "name": "üåê Fetch PlayBasket Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parser HTML corretto per PlayBasket.it - TEST UPDATE\nconsole.log('üèÄ INIZIO PARSING PLAYBASKET - TEST UPDATE');\n\nif (!items || items.length === 0) {\n  console.error('‚ùå Nessun dato ricevuto');\n  return [{ json: { success: false, error: 'No input data' } }];\n}\n\n// Accesso corretto ai dati HTML\nlet html = null;\nif (items[0].data) {\n  html = items[0].data;\n} else if (items[0].json && typeof items[0].json === 'string') {\n  html = items[0].json;\n} else if (items[0].json && items[0].json.data) {\n  html = items[0].json.data;\n}\n\nif (!html) {\n  console.error('‚ùå HTML non trovato');\n  return [{ json: { success: false, error: 'HTML not found' } }];\n}\n\nconsole.log('üìä Lunghezza HTML:', html.length);\n\n// Estrazione delle righe della classifica\nconst standings = [];\nconst rowRegex = /<tr class='row_standings'>([\\s\\S]*?)<\\/tr>/g;\nlet rowMatch;\n\nwhile ((rowMatch = rowRegex.exec(html)) !== null) {\n  const rowContent = rowMatch[1];\n  \n  try {\n    // Estrazione posizione\n    const posMatch = /<td[^>]*class='colfrozen'>(\\d+)<\\/td>/.exec(rowContent);\n    if (!posMatch) continue;\n    const position = parseInt(posMatch[1]);\n    \n    // Estrazione squadra e ID\n    const teamMatch = /<td class=\"sq colfrozen\"><a href=\"club\\.php\\?obj=(\\d+)&action=view&eid=\\d+\">([^<]+)<\\/a>/.exec(rowContent);\n    if (!teamMatch) continue;\n    \n    const teamId = teamMatch[1];\n    const teamName = teamMatch[2].trim();\n    const teamLink = `https://www.playbasket.it/toscana/club.php?obj=${teamId}&action=view&eid=4`;\n    \n    // Estrazione punti in classifica (highlighted_data)\n    const pointsMatch = /<td[^>]*class='highlighted_data'>(\\d+)<\\/td>/.exec(rowContent);\n    const points = pointsMatch ? parseInt(pointsMatch[1]) : 0;\n    \n    // Estrazione punti per partita (divisore)\n    const pointsPerGameMatch = /<td[^>]*class='divisore'>([\\d.]+)<\\/td>/.exec(rowContent);\n    const pointsPerGame = pointsPerGameMatch ? parseFloat(pointsPerGameMatch[1]) : 0;\n    \n    // Estrazione altri dati nell'ordine\n    const simpleTdRegex = /<td title='[^']*'>([^<]+)<\\/td>/g;\n    const values = [];\n    let tdMatch;\n    \n    while ((tdMatch = simpleTdRegex.exec(rowContent)) !== null) {\n      values.push(tdMatch[1].trim());\n    }\n    \n    const games = values[0] ? parseInt(values[0]) : 0;\n    const wins = values[1] ? parseInt(values[1]) : 0;\n    const losses = values[2] ? parseInt(values[2]) : 0;\n    const percentage = values[3] ? parseFloat(values[3]) : 0;\n    \n    // Estrazione striscia\n    const streakMatch = /<td[^>]*class='[^']*streak[^']*'[^>]*>([^<]+)<\\/td>/.exec(rowContent);\n    const streak = streakMatch ? streakMatch[1].trim() : '-';\n    \n    const pointsFor = values[5] ? parseInt(values[5]) : 0;\n    const pointsAgainst = values[6] ? parseInt(values[6]) : 0;\n    const quality = values[7] ? parseFloat(values[7]) : 0;\n    const pointsForPerGame = values[8] ? parseFloat(values[8]) : 0;\n    const pointsAgainstPerGame = values[9] ? parseFloat(values[9]) : 0;\n    \n    const teamData = {\n      position: position,\n      team: teamName,\n      teamId: teamId,\n      teamLink: teamLink,\n      points: points,\n      pointsPerGame: pointsPerGame,\n      games: games,\n      wins: wins,\n      losses: losses,\n      percentage: percentage,\n      streak: streak,\n      pointsFor: pointsFor,\n      pointsAgainst: pointsAgainst,\n      quality: quality.toFixed(2),\n      pointsForPerGame: pointsForPerGame,\n      pointsAgainstPerGame: pointsAgainstPerGame\n    };\n    \n    standings.push(teamData);\n    \n  } catch (error) {\n    console.error('‚ùå Errore processando riga:', error);\n  }\n}\n\n// Creazione statistiche per squadra\nconst teamStats = {};\nstandings.forEach(team => {\n  teamStats[team.team] = {\n    position: team.position,\n    points: team.points,\n    games: team.games,\n    wins: team.wins,\n    losses: team.losses,\n    winPercentage: team.percentage,\n    pointsFor: team.pointsFor,\n    pointsAgainst: team.pointsAgainst,\n    pointDifference: team.pointsFor - team.pointsAgainst,\n    averagePointsFor: team.pointsForPerGame,\n    averagePointsAgainst: team.pointsAgainstPerGame\n  };\n});\n\nconst result = {\n  standings: standings,\n  teamStats: teamStats,\n  lastUpdate: new Date().toISOString(),\n  season: '2025-2026',\n  competition: 'Serie C Maschile Toscana',\n  conference: 'Conference Nord-Ovest',\n  group: 'Girone B',\n  totalTeams: standings.length,\n  source: 'playbasket.it',\n  status: 'active'\n};\n\nconsole.log(`üéâ Parsing completato: ${standings.length} squadre processate`);\nconsole.log('üìä Prime 3 squadre:', standings.slice(0, 3));\nreturn [{ json: result }];"
      },
      "id": "node2",
      "name": "‚öôÔ∏è Parse Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.standings.length}}",
              "operation": "largerEqual",
              "value2": 10
            }
          ]
        }
      },
      "id": "node3",
      "name": "‚úÖ Check Quality",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Preparazione dati per GitHub con SHA fisso\nconst statsData = items[0].json;\n\n// Creazione contenuto Base64 per il file JSON\nconst jsonContent = JSON.stringify(statsData, null, 2);\nconst base64Content = Buffer.from(jsonContent).toString('base64');\n\n// SHA del file corrente (dal tuo messaggio)\nconst currentSha = 'c4426d5d131f4a0dbbe975f672e75f561053d431';\n\nconst result = {\n  message: `Aggiornamento automatico statistiche Serie C - ${new Date().toISOString()}`,\n  content: base64Content,\n  sha: currentSha\n};\n\nconsole.log('üîß Dati preparati per GitHub:', {\n  messageLength: result.message.length,\n  contentLength: result.content.length,\n  sha: result.sha\n});\n\nreturn [{ json: result }];"
      },
      "id": "node4",
      "name": "üîß Prepare GitHub Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 300]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/magiaslab/svbtailwindok3/contents/src/data/stats/serie-c-stats.json",
        "authentication": "headerAuth",
        "requestMethod": "PUT",
        "responseFormat": "json",
        "jsonParameters": true,
        "bodyParametersJson": "={{ $json }}",
        "options": {}
      },
      "id": "node5",
      "name": "üì§ Update GitHub File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "jsCode": "// Messaggio di successo\nconst githubResponse = items[0].json;\n\nconst message = `üéâ Test aggiornamento completato!\n\nüìä File aggiornato: ${githubResponse.content ? '‚úÖ Successo' : '‚ùå Errore'}\nüìù Commit SHA: ${githubResponse.commit ? githubResponse.commit.sha : 'N/A'}\n‚è∞ Timestamp: ${new Date().toISOString()}`;\n\nconsole.log(message);\n\nreturn [{\n  json: {\n    success: true,\n    message: message,\n    githubResponse: githubResponse,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "node6",
      "name": "üéâ Success Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1280, 300]
    },
    {
      "parameters": {
        "jsCode": "// Gestione errore\nconsole.error('‚ùå Test fallito - dati non validi o scraping fallito');\n\nreturn [{\n  json: {\n    success: false,\n    error: 'Dati non validi o scraping fallito',\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "node7",
      "name": "‚ùå Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 480]
    }
  ],
  "connections": {
    "üåê Fetch PlayBasket Data": {
      "main": [
        [
          {
            "node": "‚öôÔ∏è Parse Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚öôÔ∏è Parse Data": {
      "main": [
        [
          {
            "node": "‚úÖ Check Quality",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚úÖ Check Quality": {
      "main": [
        [
          {
            "node": "üîß Prepare GitHub Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "‚ùå Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîß Prepare GitHub Data": {
      "main": [
        [
          {
            "node": "üì§ Update GitHub File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì§ Update GitHub File": {
      "main": [
        [
          {
            "node": "üéâ Success Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    "basketball",
    "test",
    "github-update"
  ],
  "triggerCount": 0,
  "updatedAt": "2025-09-28T19:45:00.000Z",
  "versionId": "test-update-v1"
}
