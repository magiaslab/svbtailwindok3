{
  "name": "üèÄ Basket Stats Scraper - COMPLETE DYNAMIC FIXED",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "cronExpression": "0 8 * * 1,4"
            }
          ]
        }
      },
      "id": "trigger",
      "name": "‚è∞ Schedule (Mon/Thu 8AM)",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [40, 300]
    },
    {
      "parameters": {
        "url": "https://www.playbasket.it/toscana/league.php?lt=2&lf=M&lr=TO&lp=FI&lc=C%2FM&lg=1&mod=st",
        "responseFormat": "string"
      },
      "id": "node1",
      "name": "üåê Fetch PlayBasket Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/magiaslab/svbtailwindok3/contents/src/data/stats/serie-c-stats.json",
        "authentication": "headerAuth",
        "responseFormat": "json",
        "options": {}
      },
      "id": "node2",
      "name": "üì• Get JSON SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [240, 420]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/magiaslab/svbtailwindok3/contents/src/data/stats-data.ts",
        "authentication": "headerAuth",
        "responseFormat": "json",
        "options": {}
      },
      "id": "node3",
      "name": "üì• Get TS SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [240, 540]
    },
    {
      "parameters": {
        "jsCode": "// Parser HTML completo con accesso corretto ai dati multipli\nconsole.log('üèÄ INIZIO PARSING COMPLETO - ACCESSO DATI MULTIPLI');\nconsole.log('üìä Numero input ricevuti:', items.length);\n\n// Debug: stampa struttura di tutti gli input\nfor (let i = 0; i < items.length; i++) {\n  console.log(`Input ${i}:`, Object.keys(items[i]));\n  if (items[i].json) {\n    console.log(`Input ${i} JSON keys:`, Object.keys(items[i].json));\n  }\n}\n\n// Accesso ai dati HTML - primo input dal nodo HTTP\nlet html = null;\nconst htmlInput = items.find(item => item.data || (item.json && typeof item.json === 'string'));\n\nif (htmlInput) {\n  if (htmlInput.data) {\n    html = htmlInput.data;\n    console.log('‚úÖ HTML trovato in .data');\n  } else if (htmlInput.json && typeof htmlInput.json === 'string') {\n    html = htmlInput.json;\n    console.log('‚úÖ HTML trovato in .json (string)');\n  }\n} else {\n  // Fallback: prova il primo item\n  if (items[0] && items[0].data) {\n    html = items[0].data;\n    console.log('‚úÖ HTML trovato in items[0].data (fallback)');\n  }\n}\n\nif (!html || typeof html !== 'string') {\n  console.error('‚ùå HTML non trovato o non √® una stringa');\n  console.error('Struttura items[0]:', items[0]);\n  return [{ json: { success: false, error: 'HTML not found or invalid' } }];\n}\n\nconsole.log('üìÑ HTML length:', html.length);\nconsole.log('üìÑ HTML preview:', html.substring(0, 200));\n\n// Accesso ai dati SHA - cerca negli input JSON\nlet jsonSha = null;\nlet tsSha = null;\n\nfor (const item of items) {\n  if (item.json && item.json.sha && item.json.path) {\n    if (item.json.path.includes('serie-c-stats.json')) {\n      jsonSha = item.json.sha;\n      console.log('‚úÖ JSON SHA trovato:', jsonSha);\n    } else if (item.json.path.includes('stats-data.ts')) {\n      tsSha = item.json.sha;\n      console.log('‚úÖ TS SHA trovato:', tsSha);\n    }\n  }\n}\n\nif (!jsonSha || !tsSha) {\n  console.error('‚ùå SHA non trovati - JSON:', jsonSha, 'TS:', tsSha);\n  return [{ json: { success: false, error: 'SHA not found' } }];\n}\n\n// Parsing HTML (codice testato e funzionante)\nconst standings = [];\nconst rowRegex = /<tr class='row_standings'>([\\s\\S]*?)<\\/tr>/g;\nlet rowMatch;\n\nconsole.log('üîç Inizio parsing righe tabella...');\n\nwhile ((rowMatch = rowRegex.exec(html)) !== null) {\n  const rowContent = rowMatch[1];\n  \n  try {\n    const posMatch = /<td[^>]*class='colfrozen'>(\\d+)<\\/td>/.exec(rowContent);\n    if (!posMatch) continue;\n    const position = parseInt(posMatch[1]);\n    \n    const teamMatch = /<td class=\"sq colfrozen\"><a href=\"club\\.php\\?obj=(\\d+)&action=view&eid=\\d+\">([^<]+)<\\/a>/.exec(rowContent);\n    if (!teamMatch) continue;\n    \n    const teamId = teamMatch[1];\n    const teamName = teamMatch[2].trim();\n    const teamLink = `https://www.playbasket.it/toscana/club.php?obj=${teamId}&action=view&eid=4`;\n    \n    const pointsMatch = /<td[^>]*class='highlighted_data'>(\\d+)<\\/td>/.exec(rowContent);\n    const points = pointsMatch ? parseInt(pointsMatch[1]) : 0;\n    \n    const pointsPerGameMatch = /<td[^>]*class='divisore'>([\\d.]+)<\\/td>/.exec(rowContent);\n    const pointsPerGame = pointsPerGameMatch ? parseFloat(pointsPerGameMatch[1]) : 0;\n    \n    const simpleTdRegex = /<td title='[^']*'>([^<]+)<\\/td>/g;\n    const values = [];\n    let tdMatch;\n    \n    while ((tdMatch = simpleTdRegex.exec(rowContent)) !== null) {\n      values.push(tdMatch[1].trim());\n    }\n    \n    const games = values[0] ? parseInt(values[0]) : 0;\n    const wins = values[1] ? parseInt(values[1]) : 0;\n    const losses = values[2] ? parseInt(values[2]) : 0;\n    const percentage = values[3] ? parseFloat(values[3]) : 0;\n    \n    const streakMatch = /<td[^>]*class='[^']*streak[^']*'[^>]*>([^<]+)<\\/td>/.exec(rowContent);\n    const streak = streakMatch ? streakMatch[1].trim() : '-';\n    \n    const pointsFor = values[5] ? parseInt(values[5]) : 0;\n    const pointsAgainst = values[6] ? parseInt(values[6]) : 0;\n    const quality = values[7] ? parseFloat(values[7]) : 0;\n    const pointsForPerGame = values[8] ? parseFloat(values[8]) : 0;\n    const pointsAgainstPerGame = values[9] ? parseFloat(values[9]) : 0;\n    \n    standings.push({\n      position, team: teamName, teamId, teamLink, points, pointsPerGame,\n      games, wins, losses, percentage, streak, pointsFor, pointsAgainst,\n      quality: quality.toFixed(2), pointsForPerGame, pointsAgainstPerGame\n    });\n    \n    console.log(`‚úÖ Squadra ${position}: ${teamName} (${points} punti)`);\n    \n  } catch (error) {\n    console.error('‚ùå Errore processando riga:', error);\n  }\n}\n\nconsole.log(`üìä Parsing completato: ${standings.length} squadre trovate`);\n\n// Verifica qualit√† dati\nif (standings.length < 10) {\n  console.error(`‚ùå Dati insufficienti: solo ${standings.length} squadre`);\n  return [{ json: { success: false, error: `Insufficient data: ${standings.length} teams` } }];\n}\n\n// Creazione dati completi\nconst teamStats = {};\nstandings.forEach(team => {\n  teamStats[team.team] = {\n    position: team.position, points: team.points, games: team.games,\n    wins: team.wins, losses: team.losses, winPercentage: team.percentage,\n    pointsFor: team.pointsFor, pointsAgainst: team.pointsAgainst,\n    pointDifference: team.pointsFor - team.pointsAgainst,\n    averagePointsFor: team.pointsForPerGame,\n    averagePointsAgainst: team.pointsAgainstPerGame\n  };\n});\n\nconst statsData = {\n  standings, teamStats,\n  lastUpdate: new Date().toISOString(),\n  season: '2025-2026',\n  competition: 'Serie C Maschile Toscana',\n  conference: 'Conference Nord-Ovest',\n  group: 'Girone B',\n  totalTeams: standings.length,\n  source: 'playbasket.it',\n  status: 'active'\n};\n\n// Preparazione dati per GitHub\nconst jsonContent = JSON.stringify(statsData, null, 2);\nconst jsonBase64 = Buffer.from(jsonContent).toString('base64');\n\n// Preparazione contenuto TypeScript\nconst tsContent = `// Dati delle statistiche Serie C\n// Questo file viene importato direttamente dai componenti\n// Aggiornato automaticamente: ${new Date().toISOString()}\n\nexport const serieCStatsData = ${JSON.stringify(statsData, null, 2)};`;\nconst tsBase64 = Buffer.from(tsContent).toString('base64');\n\nconst result = {\n  success: true,\n  teamsCount: standings.length,\n  jsonData: {\n    message: `Aggiornamento automatico serie-c-stats.json - ${new Date().toISOString()}`,\n    content: jsonBase64,\n    sha: jsonSha\n  },\n  tsData: {\n    message: `Aggiornamento automatico stats-data.ts - ${new Date().toISOString()}`,\n    content: tsBase64,\n    sha: tsSha\n  }\n};\n\nconsole.log(`üéâ Parsing completato con successo!`);\nconsole.log(`üìä Squadre: ${standings.length}`);\nconsole.log(`üîë JSON SHA: ${jsonSha}`);\nconsole.log(`üîë TS SHA: ${tsSha}`);\n\nreturn [{ json: result }];"
      },
      "id": "node4",
      "name": "‚öôÔ∏è Parse & Prepare All",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 380]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.success}}",
              "operation": "equal",
              "value2": true
            }
          ]
        }
      },
      "id": "node5",
      "name": "‚úÖ Check Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [680, 380]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/magiaslab/svbtailwindok3/contents/src/data/stats/serie-c-stats.json",
        "authentication": "headerAuth",
        "requestMethod": "PUT",
        "responseFormat": "json",
        "jsonParameters": true,
        "bodyParametersJson": "={{ $json.jsonData }}",
        "options": {}
      },
      "id": "node6",
      "name": "üì§ Update JSON File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [880, 300]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/magiaslab/svbtailwindok3/contents/src/data/stats-data.ts",
        "authentication": "headerAuth",
        "requestMethod": "PUT",
        "responseFormat": "json",
        "jsonParameters": true,
        "bodyParametersJson": "={{ $json.tsData }}",
        "options": {}
      },
      "id": "node7",
      "name": "üì§ Update TS File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [880, 460]
    },
    {
      "parameters": {
        "url": "https://api.netlify.com/build_hooks/YOUR_BUILD_HOOK_ID",
        "requestMethod": "POST",
        "responseFormat": "json",
        "sendBody": false,
        "options": {}
      },
      "id": "node8",
      "name": "üöÄ Trigger Netlify Deploy",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1080, 380]
    },
    {
      "parameters": {
        "jsCode": "// Messaggio di successo finale completo\nconsole.log('üéâ Raccogliendo risultati finali...');\nconsole.log('üìä Input ricevuti:', items.length);\n\n// Gestione flessibile degli input (potrebbero arrivare in ordine diverso)\nlet jsonUpdate = null;\nlet tsUpdate = null;\nlet netlifyDeploy = null;\n\nfor (const item of items) {\n  if (item.json && item.json.content && item.json.content.path) {\n    if (item.json.content.path.includes('serie-c-stats.json')) {\n      jsonUpdate = item;\n      console.log('‚úÖ JSON update trovato');\n    } else if (item.json.content.path.includes('stats-data.ts')) {\n      tsUpdate = item;\n      console.log('‚úÖ TS update trovato');\n    }\n  } else if (item.statusCode === 200 || (item.json && !item.json.content)) {\n    netlifyDeploy = item;\n    console.log('‚úÖ Netlify deploy trovato');\n  }\n}\n\n// Fallback se non trova i pattern specifici\nif (!jsonUpdate && items[0]) jsonUpdate = items[0];\nif (!tsUpdate && items[1]) tsUpdate = items[1];\nif (!netlifyDeploy && items[2]) netlifyDeploy = items[2];\n\nconst jsonSuccess = jsonUpdate && jsonUpdate.json && jsonUpdate.json.content;\nconst tsSuccess = tsUpdate && tsUpdate.json && tsUpdate.json.content;\nconst netlifySuccess = netlifyDeploy && (netlifyDeploy.json || netlifyDeploy.statusCode === 200);\n\nconst message = `üéâ Aggiornamento automatico completato!\n\nüìä Risultati:\n- File JSON: ${jsonSuccess ? '‚úÖ Aggiornato' : '‚ùå Errore'}\n- File TypeScript: ${tsSuccess ? '‚úÖ Aggiornato' : '‚ùå Errore'}\n- Deploy Netlify: ${netlifySuccess ? '‚úÖ Triggerato' : '‚ùå Errore'}\n\nüìù Commit Details:\n- JSON Commit: ${jsonUpdate?.json?.commit?.sha || 'N/A'}\n- TS Commit: ${tsUpdate?.json?.commit?.sha || 'N/A'}\n\n‚è∞ Timestamp: ${new Date().toISOString()}\n\nüéØ Prossimo aggiornamento: Luned√¨/Gioved√¨ alle 8:00 AM`;\n\nconsole.log(message);\n\nreturn [{\n  json: {\n    success: jsonSuccess && tsSuccess,\n    message: message,\n    details: {\n      jsonUpdate: jsonSuccess,\n      tsUpdate: tsSuccess,\n      netlifyDeploy: netlifySuccess,\n      jsonCommit: jsonUpdate?.json?.commit?.sha,\n      tsCommit: tsUpdate?.json?.commit?.sha\n    },\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "node9",
      "name": "üéâ Final Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1280, 380]
    },
    {
      "parameters": {
        "jsCode": "// Gestione errore completa\nconsole.error('‚ùå Errore durante l\\'esecuzione del workflow');\nconsole.error('Possibili cause: scraping fallito, dati insufficienti, o errore di parsing');\n\nconst errorDetails = items[0]?.json || { error: 'Unknown error' };\n\nconst message = `‚ùå Workflow fallito\n\nüîç Dettagli errore:\n${JSON.stringify(errorDetails, null, 2)}\n\n‚è∞ Timestamp: ${new Date().toISOString()}\n\nüîÑ Il prossimo tentativo sar√†: Luned√¨/Gioved√¨ alle 8:00 AM`;\n\nconsole.error(message);\n\nreturn [{\n  json: {\n    success: false,\n    error: message,\n    errorDetails: errorDetails,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "node10",
      "name": "‚ùå Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 580]
    }
  ],
  "connections": {
    "‚è∞ Schedule (Mon/Thu 8AM)": {
      "main": [
        [
          {
            "node": "üåê Fetch PlayBasket Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "üì• Get JSON SHA",
            "type": "main",
            "index": 0
          },
          {
            "node": "üì• Get TS SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üåê Fetch PlayBasket Data": {
      "main": [
        [
          {
            "node": "‚öôÔ∏è Parse & Prepare All",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì• Get JSON SHA": {
      "main": [
        [
          {
            "node": "‚öôÔ∏è Parse & Prepare All",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì• Get TS SHA": {
      "main": [
        [
          {
            "node": "‚öôÔ∏è Parse & Prepare All",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚öôÔ∏è Parse & Prepare All": {
      "main": [
        [
          {
            "node": "‚úÖ Check Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚úÖ Check Success": {
      "main": [
        [
          {
            "node": "üì§ Update JSON File",
            "type": "main",
            "index": 0
          },
          {
            "node": "üì§ Update TS File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "‚ùå Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì§ Update JSON File": {
      "main": [
        [
          {
            "node": "üöÄ Trigger Netlify Deploy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì§ Update TS File": {
      "main": [
        [
          {
            "node": "üöÄ Trigger Netlify Deploy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üöÄ Trigger Netlify Deploy": {
      "main": [
        [
          {
            "node": "üéâ Final Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    "basketball",
    "complete",
    "dynamic-sha",
    "production",
    "fixed"
  ],
  "triggerCount": 0,
  "updatedAt": "2025-09-28T22:00:00.000Z",
  "versionId": "complete-dynamic-fixed-v1"
}
