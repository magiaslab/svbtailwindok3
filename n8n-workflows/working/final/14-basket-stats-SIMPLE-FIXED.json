{
  "name": "14 - Basket Stats SIMPLE-FIXED",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "value": "0 8 * * 1,4"
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "Schedule",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [260, 300]
    },
    {
      "parameters": {
        "url": "https://www.playbasket.it/toscana/league.php?lt=2&lf=M&lr=TO&lp=FI&lc=C%2FM&lg=1&mod=st",
        "responseFormat": "string",
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3
          }
        }
      },
      "id": "http-request",
      "name": "Get HTML",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [480, 300]
    },
    {
      "parameters": {
        "jsCode": "// === BASKET STATS SCRAPER - VERSIONE SIMPLE-FIXED ===\nconsole.log('üöÄ Inizio scraping basket stats SIMPLE-FIXED...');\n\n// Accesso ai dati HTML\nlet htmlData = '';\nif (items && items.length > 0) {\n  const item = items[0];\n  console.log('üì• Item ricevuto:', typeof item, Object.keys(item || {}));\n  \n  if (item.json && item.json.data && typeof item.json.data === 'string' && item.json.data.length > 1000) {\n    htmlData = item.json.data;\n    console.log('‚úÖ HTML trovato in item.json.data');\n  } else if (item.json && typeof item.json === 'string' && item.json.length > 1000) {\n    htmlData = item.json;\n    console.log('‚úÖ HTML trovato in item.json (string)');\n  } else if (item.data && typeof item.data === 'string' && item.data.length > 1000) {\n    htmlData = item.data;\n    console.log('‚úÖ HTML trovato in item.data');\n  }\n}\n\nif (!htmlData || htmlData.length < 1000) {\n  console.error('‚ùå HTML non trovato o troppo corto:', htmlData?.length || 0);\n  return [{\n    json: {\n      success: false,\n      error: 'HTML_NOT_FOUND',\n      message: 'Impossibile accedere ai dati HTML',\n      htmlLength: htmlData?.length || 0\n    }\n  }];\n}\n\nconsole.log('üìä HTML ricevuto, lunghezza:', htmlData.length);\n\n// Parsing della tabella\nconst tableRegex = /<table[^>]*class=[\"']league_standings_ranking stats[\"'][^>]*>([\\s\\S]*?)<\\/table>/i;\nconst tableMatch = htmlData.match(tableRegex);\n\nif (!tableMatch) {\n  console.error('‚ùå Tabella non trovata nel HTML');\n  return [{\n    json: {\n      success: false,\n      error: 'TABLE_NOT_FOUND',\n      message: 'Tabella non trovata nel HTML'\n    }\n  }];\n}\n\nconsole.log('‚úÖ Tabella trovata, lunghezza:', tableMatch[1].length);\n\n// Estrazione righe\nconst rowRegex = /<tr[^>]*>([\\s\\S]*?)<\\/tr>/gi;\nconst rows = [];\nlet match;\n\nwhile ((match = rowRegex.exec(tableMatch[1])) !== null) {\n  rows.push(match[1]);\n}\n\nconsole.log('üìã Righe trovate:', rows.length);\n\nconst standings = [];\n\n// Parsing squadre (salta header)\nfor (let i = 1; i < rows.length; i++) {\n  const rowContent = rows[i];\n  const cellRegex = /<td[^>]*>([\\s\\S]*?)<\\/td>/gi;\n  const cells = [];\n  let cellMatch;\n  \n  while ((cellMatch = cellRegex.exec(rowContent)) !== null) {\n    cells.push(cellMatch[1]);\n  }\n  \n  if (cells.length >= 11) {\n    const cleanText = (html) => html.replace(/<[^>]*>/g, '').replace(/\\s+/g, ' ').trim();\n    const extractHref = (html) => {\n      const match = html.match(/href=[\"']([^\"']*)[\"']/);\n      return match ? match[1] : '';\n    };\n    \n    // MAPPING CORRETTO DELLE CELLE\n    const position = parseInt(cleanText(cells[0])) || standings.length + 1;\n    \n    // Cella 1: Nome squadra e link\n    const teamCell = cells[1] || '';\n    const teamName = cleanText(teamCell);\n    const teamLink = extractHref(teamCell);\n    const teamIdMatch = teamLink.match(/obj=(\\d+)/);\n    const teamId = teamIdMatch ? teamIdMatch[1] : '';\n    \n    // Cella 2: Punti\n    const points = parseInt(cleanText(cells[2])) || 0;\n    \n    // Cella 4: Partite giocate\n    const games = parseInt(cleanText(cells[4])) || 0;\n    \n    // Cella 5: Vittorie\n    const wins = parseInt(cleanText(cells[5])) || 0;\n    \n    // Cella 6: Sconfitte\n    const losses = parseInt(cleanText(cells[6])) || 0;\n    \n    // Cella 7: Percentuale\n    const percentage = parseFloat(cleanText(cells[7])) || 0;\n    \n    // Cella 8: Streak\n    const streak = cleanText(cells[8]) || '-';\n    \n    // Cella 10: Points For\n    const pointsFor = parseInt(cleanText(cells[10])) || 0;\n    \n    // Points Against: calcolo basato sulla qualit√†\n    const quality = parseFloat(cleanText(cells[9])) || 50;\n    const pointsAgainst = games > 0 ? Math.max(0, Math.round(pointsFor - ((quality - 50) * games / 10))) : 0;\n    \n    standings.push({\n      position: position,\n      team: teamName,\n      teamId: teamId,\n      teamLink: teamLink.startsWith('http') ? teamLink : `https://www.playbasket.it/toscana/${teamLink}`,\n      points: points,\n      pointsPerGame: games > 0 ? (points / games).toFixed(2) : '0.00',\n      games: games,\n      wins: wins,\n      losses: losses,\n      percentage: percentage,\n      streak: streak,\n      pointsFor: pointsFor,\n      pointsAgainst: pointsAgainst,\n      quality: quality.toFixed(2),\n      pointsForPerGame: games > 0 ? Math.round(pointsFor / games) : 0,\n      pointsAgainstPerGame: games > 0 ? Math.round(pointsAgainst / games) : 0\n    });\n    \n    console.log(`‚úÖ Squadra ${position}: ${teamName} - ${points}pt, ${games}g, ${wins}w-${losses}l, PF:${pointsFor}`);\n  }\n}\n\nif (standings.length === 0) {\n  console.error('‚ùå Nessuna squadra trovata');\n  return [{\n    json: {\n      success: false,\n      error: 'NO_TEAMS_FOUND',\n      message: 'Nessuna squadra trovata'\n    }\n  }];\n}\n\nconsole.log(`‚úÖ Parsing completato: ${standings.length} squadre`);\n\n// Creazione oggetto finale\nconst now = new Date().toISOString();\nconst statsData = {\n  standings: standings,\n  teamStats: {},\n  lastUpdate: now,\n  season: '2025-2026',\n  competition: 'Serie C Maschile Toscana',\n  conference: 'Conference Nord-Ovest',\n  group: 'Girone B',\n  totalTeams: standings.length,\n  source: 'playbasket.it',\n  status: 'active'\n};\n\n// Genera teamStats\nstandings.forEach(team => {\n  statsData.teamStats[team.team] = {\n    position: team.position,\n    points: team.points,\n    games: team.games,\n    wins: team.wins,\n    losses: team.losses,\n    winPercentage: team.percentage,\n    pointsFor: team.pointsFor,\n    pointsAgainst: team.pointsAgainst,\n    pointDifference: team.pointsFor - team.pointsAgainst,\n    averagePointsFor: team.pointsForPerGame,\n    averagePointsAgainst: team.pointsAgainstPerGame\n  };\n});\n\nconsole.log('üéØ Prima squadra:', standings[0]);\nconsole.log('üéØ Ultima squadra:', standings[standings.length - 1]);\n\nreturn [{\n  json: {\n    success: true,\n    data: statsData,\n    totalTeams: standings.length,\n    lastUpdate: now\n  }\n}];"
      },
      "id": "parse-data",
      "name": "Parse Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [700, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.success}}",
              "value2": true
            }
          ],
          "number": [
            {
              "value1": "={{$json.totalTeams}}",
              "operation": "larger",
              "value2": 5
            }
          ]
        }
      },
      "id": "quality-check",
      "name": "Quality Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [920, 300]
    },
    {
      "parameters": {
        "jsCode": "// ‚ö†Ô∏è QUALITY CHECK FALLITA - NON AGGIORNARE IL FILE\nconsole.log('‚ö†Ô∏è Quality Check fallita - Mantenendo dati esistenti');\n\nconst parseData = $input.first().json;\nconst errorDetails = {\n  timestamp: new Date().toISOString(),\n  success: false,\n  action: 'NO_UPDATE',\n  reason: 'Quality check fallita',\n  details: {\n    parsingSuccess: parseData.success || false,\n    totalTeams: parseData.totalTeams || 0,\n    error: parseData.error || 'Unknown'\n  }\n};\n\nconsole.log('‚ùå QUALITY CHECK FALLITA:', errorDetails);\n\n// IMPORTANTE: Non procedere con l'aggiornamento del file\nreturn [{ json: errorDetails }];"
      },
      "id": "quality-failed",
      "name": "Quality Failed - No Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1140, 400]
    },
    {
      "parameters": {
        "jsCode": "// Preparazione dati per GitHub - VERSIONE SIMPLE-FIXED\nconsole.log('üì¶ Inizio preparazione dati GitHub...');\nconsole.log('üì• Input items:', $input.all().length);\n\n// Debug degli input\n$input.all().forEach((item, index) => {\n  console.log(`Input ${index}:`, Object.keys(item.json || {}));\n  console.log(`Input ${index} success:`, item.json?.success);\n  console.log(`Input ${index} totalTeams:`, item.json?.totalTeams);\n});\n\n// Prendi i dati dal primo input (Parse Data)\nconst parseData = $input.first().json;\nconsole.log('üìä Parse Data completo:', parseData);\n\n// Validazione dati con logging dettagliato\nconsole.log('üîç Validazione dati:');\nconsole.log('- parseData.success:', parseData.success);\nconsole.log('- parseData.data:', !!parseData.data);\nconsole.log('- parseData.totalTeams:', parseData.totalTeams);\n\nif (!parseData.success) {\n  console.error('‚ùå Parse Data non ha success: true');\n  throw new Error(`Parse Data fallito: ${parseData.error || 'Unknown error'}`);\n}\n\nif (!parseData.data) {\n  console.error('‚ùå Parse Data non ha dati');\n  throw new Error('Parse Data non contiene dati');\n}\n\nif (!parseData.totalTeams || parseData.totalTeams < 5) {\n  console.error('‚ùå Troppo poche squadre:', parseData.totalTeams);\n  throw new Error(`Troppo poche squadre trovate: ${parseData.totalTeams}`);\n}\n\nconsole.log('‚úÖ Tutte le validazioni passate');\n\n// Prepara il contenuto JSON\nconst jsonContent = JSON.stringify(parseData.data, null, 2);\nconst base64Content = Buffer.from(jsonContent, 'utf8').toString('base64');\n\n// Prepara il messaggio con data corretta\nconst now = new Date();\nconst dateStr = now.toLocaleDateString('it-IT', {\n  day: '2-digit',\n  month: '2-digit', \n  year: 'numeric'\n});\nconst timeStr = now.toLocaleTimeString('it-IT', {\n  hour: '2-digit',\n  minute: '2-digit'\n});\n\nconst commitMessage = `ü§ñ Aggiornamento automatico statistiche Serie C - ${dateStr} ${timeStr}`;\n\n// Prepara i dati per GitHub con struttura corretta\n// Per ora usiamo un SHA fittizio - il nodo successivo lo sostituir√†\nconst githubData = {\n  message: commitMessage,\n  content: base64Content,\n  sha: 'PLACEHOLDER_SHA',\n  branch: 'master'\n};\n\nconsole.log('‚úÖ Dati GitHub preparati:');\nconsole.log('- Message:', commitMessage);\nconsole.log('- Content length:', base64Content.length);\nconsole.log('- Teams:', parseData.data.totalTeams);\nconsole.log('- GitHub Data completo:', githubData);\n\nreturn [{ json: githubData }];"
      },
      "id": "prepare-github",
      "name": "Prepare GitHub Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1140, 200]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/magiaslab/svbtailwindok3/contents/src/data/stats/serie-c-stats.json",
        "options": {
          "headers": {
            "Accept": "application/vnd.github.v3+json",
            "Authorization": "token YOUR_GITHUB_TOKEN_HERE"
          },
          "qs": {
            "ref": "master"
          }
        }
      },
      "id": "get-sha",
      "name": "Get SHA",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1360, 200]
    },
    {
      "parameters": {
        "jsCode": "// Aggiorna SHA nei dati GitHub\nconsole.log('üîë Aggiornamento SHA nei dati GitHub...');\n\nconst githubData = $input.first().json;\nconst shaData = $input.last().json;\n\nconsole.log('üìä GitHub Data:', {\n  message: githubData.message,\n  contentLength: githubData.content?.length || 0,\n  currentSha: githubData.sha\n});\n\nconsole.log('üîë SHA Data:', {\n  sha: shaData.sha,\n  hasSha: !!shaData.sha\n});\n\nif (!shaData || !shaData.sha) {\n  throw new Error('SHA non trovato dal nodo Get SHA');\n}\n\n// Aggiorna il SHA\nconst updatedGithubData = {\n  ...githubData,\n  sha: shaData.sha\n};\n\nconsole.log('‚úÖ SHA aggiornato:', shaData.sha);\n\nreturn [{ json: updatedGithubData }];"
      },
      "id": "update-sha",
      "name": "Update SHA",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1580, 200]
    },
    {
      "parameters": {
        "url": "https://api.github.com/repos/magiaslab/svbtailwindok3/contents/src/data/stats/serie-c-stats.json",
        "requestMethod": "PUT",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "token YOUR_GITHUB_TOKEN_HERE"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Accept",
              "value": "application/vnd.github.v3+json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={{ $json }}"
      },
      "id": "update-github",
      "name": "Update GitHub",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1800, 200]
    },
    {
      "parameters": {
        "jsCode": "// Risultato finale - SUCCESSO\nconst summary = {\n  timestamp: new Date().toISOString(),\n  success: true,\n  message: '‚úÖ Workflow completato con successo - DATI CORRETTI',\n  details: {\n    parsing: 'OK - Mapping celle corretto',\n    qualityCheck: 'OK - Dati validi',\n    github: 'OK - File aggiornato',\n    deploy: 'OK - Netlify si attiver√† automaticamente'\n  },\n  stats: {\n    totalTeams: $input.first().json.totalTeams || 0,\n    lastUpdate: $input.first().json.lastUpdate\n  }\n};\n\nconsole.log('üéâ WORKFLOW COMPLETATO CON DATI CORRETTI:', summary);\nreturn [{ json: summary }];"
      },
      "id": "success",
      "name": "Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2020, 200]
    }
  ],
  "connections": {
    "Schedule": {
      "main": [
        [
          {
            "node": "Get HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get HTML": {
      "main": [
        [
          {
            "node": "Parse Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Data": {
      "main": [
        [
          {
            "node": "Quality Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Quality Check": {
      "main": [
        [
          {
            "node": "Prepare GitHub Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Quality Failed - No Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare GitHub Data": {
      "main": [
        [
          {
            "node": "Get SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get SHA": {
      "main": [
        [
          {
            "node": "Update SHA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update SHA": {
      "main": [
        [
          {
            "node": "Update GitHub",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update GitHub": {
      "main": [
        [
          {
            "node": "Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-10-06T17:50:00.000Z",
  "versionId": "1"
}

